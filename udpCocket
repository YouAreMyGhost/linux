#pragma once
#include <iostream>
#include <string>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>
using namespace std;\

class udpServer
{
  private:
    //源ip地址，端口号，套接字
    string ip;
    int port;
    int sock;
  public:
    //构造，初始化列表，给ip和port默认值
    udpServer(string _ip="127.0.0.1",int _port=8080)
      :ip(_ip)
      ,port(_port)
    {}
    //初始化服务器
    void initServer()
    {
      //创建套接字，IPv4协议，UDP套接字，0为默认方式
      sock=socket(AF_INET,SOCK_DGRAM,0);
      //sock默认值为3，
      cout<<"sock:"<<sock<<endl;
      struct sockaddr_in local;
      //sockaddr_in保存通信协议类型，端口号以及ip地址
      local.sin_family=AF_INET;
      local.sin_port=htons(port);
      //实际对in_addr中的s_addr进行赋值
      local.sin_addr.s_addr=inet_addr(ip.c_str());
      //绑定失败退出
      //bind（绑定函数）将套接字与主机信息绑定，成功返回0，失败返回-1；
      if(bind(sock,(struct sockaddr*)&local,sizeof(local))<0)
      {
        //标准错误输出
        cerr<<"bind error!\n"<<endl;
        exit(1);
      }
    }
    //echoserver
    void start()
    {
      //要发送的信息
      char msg[64];
      for(;;)
      {
        msg[0]='\0';
        struct sockaddr_in end_point;
        socklen_t len=sizeof(end_point);
        //recvfrom（经过socket接收消息）
        //从socket读数据msg；读写方式为0（阻塞）
        //end_point代表“谁发的数据”
        //len是输入也是输出，输入时：传入结构体大小，输出时：读到的结构体大小
        ssize_t s=recvfrom(sock,msg,sizeof(msg)-1,\
            0,(struct sockaddr*)&end_point,&len);
        if(s>0)
        {
          msg[s]='\0';
          cout<<"client# "<<msg<<endl;
          string echo_string=msg;
          echo_string+="[server echo!]";
          //sendto：将从socket中读到的信息发送
          //从socket中读取，发什么，发的长度，发送方式，往哪发，发的长度
          sendto(sock,echo_string.c_str(),echo_string.size(),\
              0,(struct sockaddr*)&end_point,len);
        }
      }
    }
    ~udpServer()
    {
      close(sock);
    }
};
